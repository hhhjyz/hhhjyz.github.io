

\documentclass{article}

\usepackage{ctex}  % 使用macOS预设的中文字体配置

\usepackage{mathptmx}

\usepackage{geometry}

\geometry{margin=1in}

\usepackage{algorithm}

\usepackage{algpseudocode}

\usepackage{amsmath}

\usepackage{graphicx}

\usepackage{svg}  % 添加这个包来更好地支持SVG文件

\usepackage{booktabs}

\usepackage{multirow}

\usepackage{xcolor}

\usepackage{hyperref}

\usepackage{tabularx}

  

\usepackage{listings}

\lstset{

    basicstyle=\ttfamily\small, % 设置基本字体样式

    keywordstyle=\color{blue}, % 设置关键词的样式

    commentstyle=\color{green!60!black}, % 设置注释的样式

    showstringspaces=false, % 不显示字符串中的空格

    numbers=left, % 行号显示在左侧

    numberstyle=\tiny, % 设置行号的样式

    breaklines=true, % 允许代码自动换行

    frame=leftline, % 给代码加上边框

    captionpos=b, % 标题位置在底部

    keepspaces=true, % 保持空格

    breakatwhitespace=false, % 允许在空白处换行

    xleftmargin=20pt, % 左边距，避免行号与代码太靠近

    tabsize=4, % 制表符大小

    language=C++, % 默认代码语言

    % 以下选项用于跨页和保持编号

    breaklines=true, % 允许代码自动换行

    breakautoindent=true, % 自动缩进断行

    numbers=left, % 行号在左侧

    numbersep=10pt, % 行号与代码之间的距离

    numberstyle=\tiny\color{gray}, % 行号样式

    firstnumber=auto, % 自动编号

    stepnumber=1, % 行号每次增加1

    escapeinside={(*@}{@*)}, % 允许在代码中插入LaTeX命令

    numberbychapter=false, % 不按章节重置行号

    extendedchars=true, % 支持扩展字符

    % 允许跨页的关键配置

    breakindent=10pt, % 换行后的缩进

    columns=flexible, % 灵活的列格式

    keepspaces=true, % 保持空格

    belowskip=\bigskipamount, % 代码块底部空间

    aboveskip=\bigskipamount, % 代码块顶部空间

    resetmargins=false, % 不重置页边距

}

\usepackage{enumitem}

\usepackage{indentfirst}  % 确保中文段落首行缩进

\usepackage{titlesec}     % 用于标题格式化

\usepackage{fancyhdr}     % 页眉页脚设置

\usepackage{booktabs}

\usepackage[version=4]{mhchem}

\usepackage{float}

\usepackage{setspace}

\usepackage{caption}

\usepackage{array}

\graphicspath{{Figs/}} % 设置图片路径

  

\hypersetup{

    colorlinks=true,

    linkcolor=black

}

  

\begin{document}

  
  

\begin{titlepage}

    \centering

    \begin{figure}[H]

        \centering

        \includegraphics[width=1.0\textwidth]{校名.png}

    \end{figure}

    \vspace{1cm}

    \Huge \textbf{MiniSQL 实验报告} \\

    \Large

    \vspace{3cm}

    % 使用两列表格结构，左侧标题右对齐，右侧内容居中

    \begin{tabular}{|r@{\hspace{1em}}c|}

        \hline

        \textbf{作业名称：} & \textbf{MiniSQL} \\

        \hline

        \textbf{姓名：} & 金祺书 \quad 庞星磊 \quad 蒋翼泽 \\

        \textbf{学号：} & 3230104248 \quad 3230100607 \quad 3230102996 \\

        \hline

        \textbf{授课教师：} & 孙建伶 \\

        \textbf{助教：} & 石宇新 / 章潇彬 \\

        \hline

    \end{tabular}

    \vspace{3cm}  % 增加表格与日期之间的空间

    \Large \textbf{2025 年 4 月 18 日}

    \vspace{2cm}

\end{titlepage}

  

\tableofcontents

  

\newpage

  

\section{Catalog Manager}

  

\subsection{关键数据成员分析}

  
  

\begin{algorithm}

\caption{IndexMetadata 类的数据成员}

\begin{lstlisting}{language=C++}

    static constexpr uint32_t INDEX_METADATA_MAGIC_NUM = 344528;

    index_id_t index_id_;

    std::string index_name_;

    table_id_t table_id_;

    std::vector<uint32_t> key_map_;

\end{lstlisting}

\end{algorithm}

  

\verb|IndexMetadata|类存储了魔数，索引ID，索引名称，表ID以及键映射。魔数用于验证元数据的完整性，索引ID和表ID用于唯一标识索引和关联的表，键映射则存储了索引中各个键的位置信息。

  

\begin{algorithm}

\caption{IndexInfo 类的数据成员}

\begin{lstlisting}{language=C++}

    IndexMetadata *meta_data_;

    Index *index_;

    IndexSchema *key_schema_;

\end{lstlisting}

  

\end{algorithm}

\verb|IndexInfo|类包含了指向索引元数据的指针，实际的索引对象以及键模式。元数据提供了索引的基本信息，\verb|index|是一个数据成员为\verb|index_id_|和\verb|*key_schema_|的类，而键模式定义了索引中使用的键的结构。

  

\begin{algorithm}

\caption{TableMetadata 类的数据成员}

\begin{lstlisting}{language=C++}

    static constexpr uint32_t TABLE_METADATA_MAGIC_NUM = 344528;

    table_id_t table_id_;

    std::string table_name_;

    page_id_t root_page_id_;

    Schema *schema_;

\end{lstlisting}

\end{algorithm}

  

\verb|TableMetadata|类存储了表的魔数，表ID，表名，根页面ID以及表的模式。魔数用于验证元数据的完整性，表ID和表名用于唯一标识表，根页面ID指向表的根页面，而模式定义了表中各列的结构。

  

\begin{algorithm}[H]

\caption{TableInfo 类的数据成员}

\begin{lstlisting}{language=C++}

    TableMetadata *table_meta_;

  TableHeap *table_heap_;

\end{lstlisting}

\end{algorithm}

  

\verb|TableInfo|类包含了指向表元数据的指针和表堆的指针。元数据提供了表的基本信息，而表堆则是实际存储表数据的结构。

  

\begin{algorithm}[H]

\caption{CatalogMeta 类的数据成员}

\begin{lstlisting}{language=C++}

    static constexpr uint32_t CATALOG_METADATA_MAGIC_NUM = 89849;

  std::map<table_id_t, page_id_t> table_meta_pages_;

  std::map<index_id_t, page_id_t> index_meta_pages_;

\end{lstlisting}

\end{algorithm}

  

\verb|CatalogMeta|类存储了\verb|Catalog|的元数据详细，包括其中所有表的元数据页面和索引的元数据页面。魔数用于验证元数据的完整性，\verb|table_meta_pages_|和\verb|index_meta_pages_|分别存储了表和索引的元数据页面ID。

  

\begin{algorithm}[H]

    \caption{CatalogManager 类的数据成员}

  

\begin{lstlisting}{language=C++}

    CatalogMeta *catalog_meta_;

  std::atomic<table_id_t> next_table_id_;

  std::atomic<index_id_t> next_index_id_;

  // map for tables

  std::unordered_map<std::string, table_id_t> table_names_;

  std::unordered_map<table_id_t, TableInfo *> tables_;

  // map for indexes: table_name->index_name->indexes

  std::unordered_map<std::string, std::unordered_map<std::string, index_id_t>> index_names_;

  std::unordered_map<index_id_t, IndexInfo *> indexes_;

  

\end{lstlisting}

\end{algorithm}

  

\verb|Catalog Manager|类是整个目录管理器的核心，包含了一个指向目录元数据的指针,可供分配的下一个表ID和索引ID。它维护了表名到表ID的映射，表ID到\verb|TableInfo|的映射，索引名到索引ID的映射，以及索引ID到\verb|IndexInfo|的映射。

  

\subsection{GetSerializedSize 方法分析}

  

我们可以通过观察各个元数据的\verb|SerializeTo|函数来分析元数据需要的空间大小。

  

以CatalogMeta为例，其\verb|SerializeTo|函数如下：

  

\begin{algorithm}[H]

\caption{CatalogMeta 类的 SerializeTo 方法}

\begin{lstlisting}{language=C++}

    void CatalogMeta::SerializeTo(char *buf) const {

  ASSERT(GetSerializedSize() <= PAGE_SIZE, "Failed to serialize catalog metadata to disk.");

  MACH_WRITE_UINT32(buf, CATALOG_METADATA_MAGIC_NUM);

  buf += 4;

  MACH_WRITE_UINT32(buf, table_meta_pages_.size());

  buf += 4;

  MACH_WRITE_UINT32(buf, index_meta_pages_.size());

  buf += 4;

  for (auto iter : table_meta_pages_) {

    MACH_WRITE_TO(table_id_t, buf, iter.first);

    buf += 4;

    MACH_WRITE_TO(page_id_t, buf, iter.second);

    buf += 4;

  }

  for (auto iter : index_meta_pages_) {

    MACH_WRITE_TO(index_id_t, buf, iter.first);

    buf += 4;

    MACH_WRITE_TO(page_id_t, buf, iter.second);

    buf += 4;

  }

}

  

\end{lstlisting}

\end{algorithm}

  

根据目录元信息的序列化函数，可以算出buf的位移量，也就是最后序列化的大小

  

\begin{algorithm}[H]

\caption{CatalogMeta 类的 GetSerializedSize 方法}

\begin{lstlisting}{language=C++}

    uint32_t CatalogMeta::GetSerializedSize() const {

        //ASSERT(false, "Not Implemented yet");

        uint32_t size = sizeof(uint32_t) * 3 + \

        (sizeof(table_id_t) + sizeof(page_id_t)) * table_meta_pages_.size() + \

        (sizeof(index_id_t) + sizeof(page_id_t)) * index_meta_pages_.size(); // magic num + table nums + index nums

        return 0;

      }

\end{lstlisting}

\end{algorithm}

  

table和index的\verb|GetSerializedSize|方法也类似，在此不多做赘述。

  

\subsection{IndexInfo 的初始化}

  

由第一部分的分析可以知道，\verb|IndexInfo|类包含了指向索引元数据的指针，实际的索引对象以及键模式。

而\verb|IndexInfo|的初始化主要根据\verb|IndexMetadata|反序列化得到的\verb|IndexMetadata|对象来完成。

  

\begin{algorithm}[H]

\caption{IndexInfo 类的构造函数}

\begin{lstlisting}{language=C++}

    void Init(IndexMetadata *meta_data, TableInfo *table_info, BufferPoolManager *buffer_pool_manager) {

    meta_data_ = meta_data;

  

    const std::vector<uint32_t> &key_map = meta_data_->GetKeyMapping();

  

    TableSchema* table_schema = table_info->GetSchema();

    key_schema_ = IndexSchema::ShallowCopySchema(table_schema, key_map);

  

    index_ = CreateIndex(buffer_pool_manager, "bptree");

  }

  \end{lstlisting}

\end{algorithm}

首先，我们加载索引元数据，从中提取键映射信息。接着，通过TableInfo 获得\verb|table_schema|,由于\verb|key_schema_|中包含的列和\verb|table_schema|中的列使用的应当是同一份内存，

所以将使用浅拷贝函数，根据\verb|key_map|来获得需要的列存入\verb|key_schema_|中。

最后，以bp树的方式在缓冲池建立索引。

  
  

\subsection{CatalogManager 成员函数的实现}

  

\subsubsection{}

  

\end{document}