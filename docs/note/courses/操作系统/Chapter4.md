# Threads

![](assets/Pasted%20image%2020250925165515.png)

heap 和 stack 在线程之间不共享

响应速度更快，线程之间共享代码和全局内存，起进程代价比较大，而线程比较容易

由用户端的线程库来管理

**多对一 (Many-to-One)**  线程管理是高效的，但如果进行系统调用则会阻塞，内核一次只能调度一个线程。

**一对一 (One-to-One)** 并发性更高，但是创建线程的开销很大。

**多对多 (Many-to-Many)**  灵活。

某些 Unix 系统有两个版本的 `fork()`：一个版本会复制所有的线程，而另一个版本只复制调用 `fork()` 的那个线程。

`exec()` 将会替换整个进程。

**thred cancellation**:

- 在一个线程完成其任务之前就终止它。

- 两种通用方法： 
- **异步取消 (Asynchronous cancellation)**：立即终止目标线程。 
- **延迟取消 (Deferred cancellation)**：允许目标线程通过一个标志位来周期性地检查自己是否应该被取消。

### 0.1 线程私有数据 (Thread Specific Data)
- 允许每个线程拥有自己的数据副本。
- 当您无法控制线程创建过程时（例如，使用线程池时），此功能很有用。
    
    - 与进程不同，单个程序中的所有线程共享相同的地址空间。这意味着如果一个线程修改了内存中的某个位置（例如，一个全局变量），这个改变对所有其他线程都是可见的。
        
    - **线程私有数据区 (thread-specific data area)**：存储在该区域的变量会为每个线程复制一份，每个线程都可以修改自己的变量副本而不会影响其他线程。
### 0.2 调度器激活 (Scheduler Activations)

- 多对多（M:M）和两级模型都要求进行通信，以维持分配给应用程序的内核线程的适当数量。
    
- **LWP (Light-weight process - 轻量级进程)** 是附加到内核线程上的一个**虚拟处理器**。
    
- 调度器激活提供了**上行调用 (upcalls)** —— 一种从内核到线程库的通信机制。
    
- 上行调用由线程库通过一个**上行调用处理器 (upcall handler)** 来处理。
    
- 这种通信允许应用程序维持正确数量的内核线程。
    
    - 当一个应用程序线程即将阻塞时，就会触发一个上行调用。
