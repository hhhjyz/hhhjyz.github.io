# 前置知识

## 1 数据操作与数据预处理

张量表示一个由数值组成的数组，这个数组可能有多个维度

**pytorch 操作：**

- `x = torch.arange(num)`，创建一个包含0开始的前12个整数
- `x.shape` 通过张量的shape属性访问张量沿每个轴的长度
- `x.numel` 检查张量中元素的总数/大小
- `x.reshape(num_x,num_y)` 改变一个张量的形状而不改变元素数量和元素值，张量的大小不会改变。不许要手动指定每一个维度，可以令`num`为`-1`使其自动计算维度
- `torch.zeros((x,y,z,...))` 创建全0张量
- `torch.ones((x,y,z,...))` 创建全1张量
- `torch.randn(x,y,...)` 元素随机的张量
- `torch.tensor([[2, 1, 4, 3], [1, 2, 3, 4], [4, 3, 2, 1]])` 提供包含数值的Python列表（或嵌套列表），来为所需张量中的每个元素赋予确定值
- `x+y,x-y,x*y,x/y,x**y,torch.exp(x)` 按元素操作
- `torch.cat((x,y),dim=?)`,把多个张量连接在一起
- `x.sum()` 对所有元素求和，产生一个单元素张量

### 1.1 广播机制

 在某些情况下，即使形状不同，我们仍然可以通过调用 _广播机制_（broadcasting mechanism）来执行按元素操作。这种机制的工作方式如下：

1. 通过适当复制元素来扩展一个或两个数组，以便在转换之后，两个张量具有相同的形状；
    
2. 对生成的数组执行按元素操作。

在大多数情况下，我们将沿着数组中长度为1的轴进行广播。

### 1.2 索引与切片

与任何Python数组一样：第一个元素的索引是0，最后一个元素索引是-1； 可以指定范围以包含第一个元素和最后一个之前的元素。

### 1.3 节省内存

`id()`函数给我们提供了内存中引用对象的确切位置

我们可以使用切片表示法将操作的结果分配给先前分配的数组，例如`Y[:] = <expression>`。

`+=`操作也能够减少操作的内存开销

### 1.4 转换为其他python对象


## 2 数据预处理

CSV文件： 逗号分隔符文件


要从创建的CSV文件中加载原始数据集，我们导入`pandas`包并调用`read_csv`函数。

```
#加载数据集
import pandas as pd
data = pd.read_csv(data_file)
print(data)
#处理缺失值

```

## 3 线性代数

```
x = torch.arange(4)
x.shape #形状
A = torch.arange(20).reshape(5,4)#矩阵
A.T #转置

```